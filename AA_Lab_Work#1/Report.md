# Report on LabWork#1
## Реалізація 
Я обрала двозв'язний впорядкований список як спосіб реалізації множин. Це полегшує навігацію у самій множині, що в свою чергу полегшує видалення та обхід елементів. Також всі елементи завжди впорядковані за зростанням, що дозволяє додавати елементи без необхідності подальшого сортування множини. 

Було введено такі *операції над множинами*:
- Insert: включення елемента у множину (без можливості дублювання)
- Delete: видалення елементу
- Search: перевірка наявності елемента
- Clear: очистка множини
- Union: об'єднання множин
- Intersection: перетин
- SetDifference: різниця
- SymDifference: симетрична різниця
- IsSubset: перевірка, чи є одна множина підмножиною іншої
- 
Також окремо заборонено копіювання (29 рядок коду), щоб уникати проблеми з видаленням динамічних вузлів.
## Аналіз часу роботи операцій
Я аналізувала операцію Search, як було вказано в завданні до лабораторної, та операцію SetDifference, яку обрала сама.

Для *Search* я окремо проводила аналіз для множин з наявним та відсутнім елементом, адже в останньому випадку необхідно обійти весь список, що збільшує час виконання операції. Час виконання збільшується лінійно зі збільшенням розміру множини, оскільки складністю є *O(n)*.

Час виконання операції *SetDifference* зростає набагато швидше, адже виконується пошук кожного елемента однієї множини в другій, складністю є *O(nm)*. 

Результати, отримані експериментально, знаходяться тут: results.csv. Щоб файл відкрився охайною таблицею, краще зробити це так: Завантажити файл -> Відкрити Excel -> Дані -> З текстового файлу або CSV-файлу -> Завантажити.

Можна помітити, що для невеликих множин операції виконуються дуже швидко (у наносекундах - Search, у мілісекундах - SetDifference). Для великих множин Search залишається порівняно швидким, а ось SetDifference вже займає значний час. 

Як висновок можна сказати, що оформлення множини двозв'язним впорядкованим списком є зручним для невеликих множин, але у випадку великого обсягу даних краще використовувати інші структури.
