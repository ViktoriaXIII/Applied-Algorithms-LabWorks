# Report on LabWork#2
У коді графи описані двома абстрактними класами Graph та WeightedGraph, які у свою чергу мають по два нащадки: один - неорієнтований, другий - орієнтований. Основним видом представлення я обрала списки суміжності, але в ході виконання Завдання №4 було додано конвертор у матрицю суміжності. Для обидвох способів є методи для виведення графів у консоль.

Кожен клас має конструктор для створення порожнього графа із заданою кількістю вершин, який за допомогою операцій додавання/видалення вершини/ребра можна оформити у будь який спосіб.  Варто зауважити, що для абстрактних класів операції додавання/видалення ребра є не визначеними. Це пов'язано із залежністю поведінки графа під час цієї операції та властивістю орієнтованості.

*Оцінка складності операцій додавання/видалення вершини/ребра:*
- Додавання вершини: *О(1)*.
  Адже всьго лише додається новий елемент у вектор
- Видалення вершини: *О(n+m)*.
  Обходимовсі вершини (n) та видаляємо елемент зі списку (m)
- Додавання ребра: *О(1)*.
  Виконуємо лише додавання одного (двох) елемента у конкретний список
- Видалення ребра: *О(deg u) або О(deg u + deg v)*.
  Видаляємо всі елементи одного (двох) списків

  Також, як я вже писала, кожен клас має конвертор у матрицю суміжності. Його складність роботи я оцінюю як О(n^2 + m), що описує ініціалізацію та позначення ребер.

  Також кожен клас має конструктор для генерування випадкових графів у моделі Ердеша-Реньї, який використовує відповідну функцію. Вона, у свою чергу, є не визначеною для абстрактних класів знову ж таки через відсутність в них конкретизації, чи є вони орієнтовними чи ні.

  Для візуального відображення згенерованих графів, у ході виконання коду будуть утворені файли формату Graphviz DOT. Їх текстовий вміст можна вставити на ресурс https://dreampuf.github.io/GraphvizOnline, а в результаті отримати гарне зображення.
